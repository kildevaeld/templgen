import {
    Expression, TemplateExpression, RawExpression, LoopExpression,
    ConditionalExpression, ArithmeticExpression, ImportExpression,
    OperationExpression, LiteralExpression, FunctionCallExpression,
    TenaryExpression, BlockExpression, CommentExpression, UserTypeExpression,
    ContextExpression, PropertyExpression, AssignmentExpression, PrimitiveExpression,
    AccessorExpression, BodyExpression, CustomTypeExpression, ParameterExpression, ArrayTypeExpression, VariableExpression,
} from '../expressions';
import { Primitive, Token, Operator, MathOperator } from '../types';
import { AbstractExpressionVisitor } from '../visitor';
import { Options } from './options';
import * as Path from 'path';
import camelCase from 'camelcase';

function isLiteralExp(a: any): a is LiteralExpression {
    return a instanceof LiteralExpression
}

function trim(s: string) {
    return s.replace(/\s+$/, "");
}

function ucfirst(s: string) {
    return s[0].toUpperCase() + s.substring(1);
}

export interface TypeScriptOptions extends Options {
    package: string;

}

export class TypescriptVisitor extends AbstractExpressionVisitor {


    options: TypeScriptOptions | undefined;
    current?: ContextExpression;
    parse(expression: ContextExpression, options: TypeScriptOptions) {
        if (this.current) throw new Error('already running');
        this.current = expression;
        this.options = options;


        let out: string;
        try {
            out = this.visit(expression);
        } catch (e) {
            this.current = void 0;
            throw e;
        }
        this.current = void 0;
        const header = `// Automatically generated by templgen - DO NOT EDIT\n`
        return header + out;
    }

    visitBody(expression: BodyExpression) {
        return expression.value.map(m => this.visit(m)).join('\n');
    }
    //incontext = false;
    trim = false;
    visitAccessor(expression: AccessorExpression) {
        let str = expression.names[0];
        for (let i = 1, ii = expression.names.length; i < ii; i++) {
            let v = expression.names[i];
            if (v.match(/\d+/))
                str += '[' + v + ']';
            else
                str += '.' + v;
        }
        return str;
    }


    visitTemplateExpression(e: TemplateExpression) {


        // let params = e.parameters.length ? e.parameters.map(m => this.visit(m)).join(', ') + ', ' : ''
        // params += 'buf *bytes.Buffer';

        let params = e.parameters.map(m => this.visit(m)).join(', ');

        let out = [
            `export function ${e.name} (${params}) {`,
            '  var buffer = ""'
        ]


        out.push(this.visit(e.body));
        out.push('  return buffer;');
        out.push('}');

        return out.join('\n');
    }

    visitAssignmentExpression(e: AssignmentExpression) {
        return this.write(e.expression, !!!e.modifier);
    }


    visitRawExpression(expression: RawExpression) {
        return this.write(expression);
    }

    visitLoopExpression(e: LoopExpression) {
        let out = [];

        let iterator = (e.iterator as any).resolvedAs || e.iterator
        const val = this.visit(e.value),
            iter = this.visit(e.iterator);
        if (iterator.nodeType == Token.Primitive && (iterator as PrimitiveExpression).type != Primitive.String) {
            if (iterator.type != Primitive.Int && iterator != Primitive.Float)
                throw new TypeError(`type ${Primitive[(iterator as PrimitiveExpression).type]} is not iterable`);

            out.push(`  for (let __i = 0; __i < ${iter}; __i++) {\n`);
            if (e.key) out.push(`    const ${this.visit(e.key)} = __i;\n`);
            out.push(`    const ${val} = __i\n`);

        } else {

            if (iterator.nodeType == Token.UserType) {
                out.push(`  for (let __i = 0, __ii = Object.keys(${iter}); __i < __ii; __i++) {\n`);
                if (e.key) out.push(`    const ${this.visit(e.key)} = ${iter}[__i];\n`);
                out.push(`    const ${val} = ${iter}[${iter}[__i]];\n`);
            } else {
                out.push(`  for (let __i = 0, __ii = ${iter}.length; __i < __ii; __i++) {\n`)
                if (e.key) out.push(`    const ${this.visit(e.key)} = __i;\n`);
                out.push(`    const ${val} = ${iter}[__i]\n`);
            }
        }

        out.push(this.visit(e.body).split('\n').map(m => '  ' + m).join('\n'));
        out.push('\n  }');



        return out.join('');
    }

    visitConditionalExpression(expression: ConditionalExpression) {

        let e = expression.expression;

        let condition = ""
        if (e instanceof AccessorExpression) {
            switch (e.resolvedAs!.nodeType) {
                case Token.Array:
                    condition = `${this.visit(e)}.length > 0`
                    break;
                case Token.Primitive:
                    condition = (() => {
                        switch ((e.resolvedAs! as any).type) {
                            case Primitive.String: return `${this.visit(e)}.length > 0`;
                            case Primitive.Float:
                            case Primitive.Int:
                                return `${this.visit(e)} > 0`
                            default:
                                return ""
                        }
                    })();


            }

            //condition = this.visit(e)
        } else {
            condition = this.visit(e);
        }

        let out = [`  if (${condition}) {\n${this.visit(expression.body).split('\n').map(m => '  ' + m).join('\n')}\n  }`];

        if (expression.elif.length) {
            out.push(...expression.elif.map(m => `  else if (${this.visit(m.expression!)}) { \n${this.visit(m.body).split('\n').map(m => '  ' + m).join('\n')} \n  }`))
        }

        if (expression.el) {
            out.push(`  else {\n${this.visit(expression.el).split('\n').map(m => '  ' + m).join('\n')}\n  }`)
        }
        return out.join('') + '\n';

    }


    visitArithmeticExpression(expression: ArithmeticExpression) {
        if (isLiteralExp(expression.left) && expression.left.type == Primitive.Int &&
            isLiteralExp(expression.right) && expression.right.type == Primitive.Int
        ) {
            return expression.left.value + expression.right.value + '';
        }

        let o = (function () {
            switch (expression.operator) {
                case MathOperator.Add: return "+";
                case MathOperator.Div: return "/";
                case MathOperator.Mod: return "%";
                case MathOperator.Mul: return "*";
                case MathOperator.Sub: return "-";
            }
        })();

        return this.visit(expression.left) + ` ${o} ` + this.visit(expression.right);

    }

    visitBinaryOperationExpression(expression: OperationExpression) {

        let out = [this.visit(expression.left)];
        out.push((function () {
            switch (expression.operator) {
                case Operator.Eq: return "==";
                case Operator.Gt: return ">";
                case Operator.Gte: return ">=";
                case Operator.Lt: return "<";
                case Operator.Lte: return "<=";
                case Operator.Mod: return "%";
                case Operator.Neq: return "!=";
            }
        })())

        out.push(this.visit(expression.right));

        return out.reverse().join(' ');
    }
    visitLiteralExpression(expression: LiteralExpression) {
        switch (expression.type) {
            case Primitive.String: return `"${expression.value}"`;
            case Primitive.Float:
            case Primitive.Int: return expression.value + '';
            case Primitive.Boolean: return expression.value ? 'true' : 'false'
        }
    }

    visitFunctionCallExpression(expression: FunctionCallExpression) {

        let params = expression.parameters.map(m => {
            let e = (m as any).resolvedAs || m;
        });

        let name = expression.name;
        if (expression.resolvedAs!.contextId != this.current!.id) {
            let im = expression.resolvedAs;
            const i = this.current!.value.value.find(m => {
                if (m.nodeType != Token.Import) return false;
                return (m as ImportExpression).importId === im.contextId;
            });
            if (!i) throw new TypeError('not found');
            name = `${(i as any).ns}.${expression.name}`
        }


        return `${name}(${(expression.parameters || []).map(m => this.visit(m))}) `;
    }
    visitTenaryExpression(expression: TenaryExpression) {
        throw new Error("Method not implemented.");
    }
    visitBlockExpression(expression: BlockExpression) {
        throw new Error("Method not implemented.");
    }
    visitCommentExpression(expression: CommentExpression) {
        return `/*\n${expression.comment}\n*/`;
    }
    visitContextExpression(expression: ContextExpression) {
        let out = this.visit(expression.value);
        return out;
    }
    visitPropertyExpression(e: PropertyExpression) {
        return `  ${e.name}: ${this.visit(e.type)}`
    }
    visitPrimitiveExpression(expression: PrimitiveExpression) {
        switch (expression.type) {
            case Primitive.Int: return "number"
            case Primitive.Float: return 'number';
            case Primitive.Boolean: return "boolean";
            case Primitive.Date: return "Date";
            case Primitive.String: return 'string';
        }
    }

    visitCustomType(e: CustomTypeExpression) {
        let out = [`export interface ${ucfirst(e.name)} {\n`];
        out.push(e.properties.map(m => this.visit(m)).join(';\n'));
        out.push(';\n}\n')
        return out.join('');
    }
    visitParamterType(expression: ParameterExpression) {
        // let iut = expression.type.nodeType === Token.UserType;
        return expression.name + ': ' + this.visit(expression.type);
    }

    visitArrayType(e: ArrayTypeExpression): any {
        return this.visit(e.type) + '[]';
    }

    visitUserType(expression: UserTypeExpression) {

        if (expression.resolvedAs!.contextId != this.current!.id) {
            let im = expression.resolvedAs;
            const i = this.current!.value.value.find(m => {
                if (m.nodeType != Token.Import) return false;
                return (m as ImportExpression).importId === im.contextId;
            });

            if (!i) throw new TypeError('not found');
            return `${(i as any).ns}.${ucfirst(expression.name)}`;
        }

        return ucfirst(expression.name);

    }

    write(s: Expression, escape: boolean = true) {
        if (!s) return '';
        let t: Expression | undefined;

        switch (s.nodeType) {
            case Token.Accessor: {
                t = (s as AccessorExpression).resolvedAs!;
                let key = this.visit(s);

                if (t instanceof PrimitiveExpression) {
                    return '  buffer += ' + key + ';';
                } else {
                    console.log(s)
                    throw new Error(`cannot write '${Token[t.nodeType]}'`)
                }


            } break;
            case Token.Raw:
                return '  buffer += "' + trim((s as RawExpression).value.replace(/\n/gm, '\\n')).replace(/"/gm, '\\"') + '";';
            case Token.FunctionCall: {
                return `  buffer += ${this.visit(s)};`;
            } break;
            case Token.Arithmetic:
                return `  buffer += (${this.visit(s)});`

            default:
                throw new Error('write ' + s);
        }

        return ''


    }

    visitVariable(e: VariableExpression): any {
        return e.value;
    }

    visitImport(e: ImportExpression): any {
        const ext = Path.extname(e.path)
        let base = Path.basename(e.path, ext);
        const dir = Path.dirname(e.path);
        let imp = Path.join(dir, base);
        if (dir == '.') imp = "./" + base;
        base = camelCase(base);
        (e as any).ns = base;
        return `import * as ${base} from '${imp}${ext ? ext : ''}';`;
    }

}
