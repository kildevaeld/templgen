"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
}
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
}
Object.defineProperty(exports, "__esModule", { value: true });
const expressions_1 = require("../expressions");
const types_1 = require("../types");
const visitor_1 = require("../visitor");
const Path = __importStar(require("path"));
const camelcase_1 = __importDefault(require("camelcase"));
function isLiteralExp(a) {
    return a instanceof expressions_1.LiteralExpression;
}
function trim(s) {
    return s.replace(/\s+$/, "");
}
function ucfirst(s) {
    return s[0].toUpperCase() + s.substring(1);
}
class TypescriptVisitor extends visitor_1.AbstractExpressionVisitor {
    constructor() {
        super(...arguments);
        //incontext = false;
        this.trim = false;
    }
    parse(expression, options) {
        if (this.current)
            throw new Error('already running');
        this.current = expression;
        this.options = options;
        let out;
        try {
            out = this.visit(expression);
        }
        catch (e) {
            this.current = void 0;
            throw e;
        }
        this.current = void 0;
        const header = `// Automatically generated by templgen - DO NOT EDIT\n`;
        return header + out;
    }
    visitBody(expression) {
        return expression.value.map(m => this.visit(m)).join('\n');
    }
    visitAccessor(expression) {
        let str = expression.names[0];
        for (let i = 1, ii = expression.names.length; i < ii; i++) {
            let v = expression.names[i];
            if (v.match(/\d+/))
                str += '[' + v + ']';
            else
                str += '.' + v;
        }
        return str;
    }
    visitTemplateExpression(e) {
        // let params = e.parameters.length ? e.parameters.map(m => this.visit(m)).join(', ') + ', ' : ''
        // params += 'buf *bytes.Buffer';
        let params = e.parameters.map(m => this.visit(m)).join(', ');
        let out = [
            `export function ${e.name} (${params}) {`,
            '  var buffer = ""'
        ];
        out.push(this.visit(e.body));
        out.push('  return buffer;');
        out.push('}');
        return out.join('\n');
    }
    visitAssignmentExpression(e) {
        return this.write(e.expression, !!!e.modifier);
    }
    visitRawExpression(expression) {
        return this.write(expression);
    }
    visitLoopExpression(e) {
        let out = [];
        let iterator = e.iterator.resolvedAs || e.iterator;
        const val = this.visit(e.value), iter = this.visit(e.iterator);
        if (iterator.nodeType == types_1.Token.Primitive && iterator.type != types_1.Primitive.String) {
            if (iterator.type != types_1.Primitive.Int && iterator != types_1.Primitive.Float)
                throw new TypeError(`type ${types_1.Primitive[iterator.type]} is not iterable`);
            out.push(`  for (let __i = 0; __i < ${iter}; __i++) {\n`);
            if (e.key)
                out.push(`    const ${this.visit(e.key)} = __i;\n`);
            out.push(`    const ${val} = __i\n`);
        }
        else {
            if (iterator.nodeType == types_1.Token.UserType) {
                out.push(`  for (let __i = 0, __ii = Object.keys(${iter}); __i < __ii; __i++) {\n`);
                if (e.key)
                    out.push(`    const ${this.visit(e.key)} = ${iter}[__i];\n`);
                out.push(`    const ${val} = ${iter}[${iter}[__i]];\n`);
            }
            else {
                out.push(`  for (let __i = 0, __ii = ${iter}.length; __i < __ii; __i++) {\n`);
                if (e.key)
                    out.push(`    const ${this.visit(e.key)} = __i;\n`);
                out.push(`    const ${val} = ${iter}[__i]\n`);
            }
        }
        out.push(this.visit(e.body).split('\n').map(m => '  ' + m).join('\n'));
        out.push('\n  }');
        return out.join('');
    }
    visitConditionalExpression(expression) {
        let e = expression.expression;
        let condition = "";
        if (e instanceof expressions_1.AccessorExpression) {
            switch (e.resolvedAs.nodeType) {
                case types_1.Token.Array:
                    condition = `${this.visit(e)}.length > 0`;
                    break;
                case types_1.Token.Primitive:
                    condition = (() => {
                        switch (e.resolvedAs.type) {
                            case types_1.Primitive.String: return `${this.visit(e)}.length > 0`;
                            case types_1.Primitive.Float:
                            case types_1.Primitive.Int:
                                return `${this.visit(e)} > 0`;
                            default:
                                return "";
                        }
                    })();
            }
            //condition = this.visit(e)
        }
        else {
            condition = this.visit(e);
        }
        let out = [`  if (${condition}) {\n${this.visit(expression.body).split('\n').map(m => '  ' + m).join('\n')}\n  }`];
        if (expression.elif.length) {
            out.push(...expression.elif.map(m => `  else if (${this.visit(m.expression)}) { \n${this.visit(m.body).split('\n').map(m => '  ' + m).join('\n')} \n  }`));
        }
        if (expression.el) {
            out.push(`  else {\n${this.visit(expression.el).split('\n').map(m => '  ' + m).join('\n')}\n  }`);
        }
        return out.join('') + '\n';
    }
    visitArithmeticExpression(expression) {
        if (isLiteralExp(expression.left) && expression.left.type == types_1.Primitive.Int &&
            isLiteralExp(expression.right) && expression.right.type == types_1.Primitive.Int) {
            return expression.left.value + expression.right.value + '';
        }
        let o = (function () {
            switch (expression.operator) {
                case types_1.MathOperator.Add: return "+";
                case types_1.MathOperator.Div: return "/";
                case types_1.MathOperator.Mod: return "%";
                case types_1.MathOperator.Mul: return "*";
                case types_1.MathOperator.Sub: return "-";
            }
        })();
        return this.visit(expression.left) + ` ${o} ` + this.visit(expression.right);
    }
    visitBinaryOperationExpression(expression) {
        let out = [this.visit(expression.left)];
        out.push((function () {
            switch (expression.operator) {
                case types_1.Operator.Eq: return "==";
                case types_1.Operator.Gt: return ">";
                case types_1.Operator.Gte: return ">=";
                case types_1.Operator.Lt: return "<";
                case types_1.Operator.Lte: return "<=";
                case types_1.Operator.Mod: return "%";
                case types_1.Operator.Neq: return "!=";
            }
        })());
        out.push(this.visit(expression.right));
        return out.reverse().join(' ');
    }
    visitLiteralExpression(expression) {
        switch (expression.type) {
            case types_1.Primitive.String: return `"${expression.value}"`;
            case types_1.Primitive.Float:
            case types_1.Primitive.Int: return expression.value + '';
            case types_1.Primitive.Boolean: return expression.value ? 'true' : 'false';
        }
    }
    visitFunctionCallExpression(expression) {
        let params = expression.parameters.map(m => {
            let e = m.resolvedAs || m;
        });
        let name = expression.name;
        if (expression.resolvedAs.contextId != this.current.id) {
            let im = expression.resolvedAs;
            const i = this.current.value.value.find(m => {
                if (m.nodeType != types_1.Token.Import)
                    return false;
                return m.importId === im.contextId;
            });
            if (!i)
                throw new TypeError('not found');
            name = `${i.ns}.${expression.name}`;
        }
        return `${name}(${(expression.parameters || []).map(m => this.visit(m))}) `;
    }
    visitTenaryExpression(expression) {
        throw new Error("Method not implemented.");
    }
    visitBlockExpression(expression) {
        throw new Error("Method not implemented.");
    }
    visitCommentExpression(expression) {
        return `/*\n${expression.comment}\n*/`;
    }
    visitContextExpression(expression) {
        let out = this.visit(expression.value);
        return out;
    }
    visitPropertyExpression(e) {
        return `  ${e.name}: ${this.visit(e.type)}`;
    }
    visitPrimitiveExpression(expression) {
        switch (expression.type) {
            case types_1.Primitive.Int: return "number";
            case types_1.Primitive.Float: return 'number';
            case types_1.Primitive.Boolean: return "boolean";
            case types_1.Primitive.Date: return "Date";
            case types_1.Primitive.String: return 'string';
        }
    }
    visitCustomType(e) {
        let out = [`export interface ${ucfirst(e.name)} {\n`];
        out.push(e.properties.map(m => this.visit(m)).join(';\n'));
        out.push(';\n}\n');
        return out.join('');
    }
    visitParamterType(expression) {
        // let iut = expression.type.nodeType === Token.UserType;
        return expression.name + ': ' + this.visit(expression.type);
    }
    visitArrayType(e) {
        return this.visit(e.type) + '[]';
    }
    visitUserType(expression) {
        if (expression.resolvedAs.contextId != this.current.id) {
            let im = expression.resolvedAs;
            const i = this.current.value.value.find(m => {
                if (m.nodeType != types_1.Token.Import)
                    return false;
                return m.importId === im.contextId;
            });
            if (!i)
                throw new TypeError('not found');
            return `${i.ns}.${ucfirst(expression.name)}`;
        }
        return ucfirst(expression.name);
    }
    write(s, escape = true) {
        if (!s)
            return '';
        let t;
        switch (s.nodeType) {
            case types_1.Token.Accessor:
                {
                    t = s.resolvedAs;
                    let key = this.visit(s);
                    if (t instanceof expressions_1.PrimitiveExpression) {
                        return '  buffer += ' + key + ';';
                    }
                    else {
                        console.log(s);
                        throw new Error(`cannot write '${types_1.Token[t.nodeType]}'`);
                    }
                }
                break;
            case types_1.Token.Raw:
                return '  buffer += "' + trim(s.value.replace(/\n/gm, '\\n')).replace(/"/gm, '\\"') + '";';
            case types_1.Token.FunctionCall:
                {
                    return `  buffer += ${this.visit(s)};`;
                }
                break;
            case types_1.Token.Arithmetic:
                return `  buffer += (${this.visit(s)});`;
            default:
                throw new Error('write ' + s);
        }
        return '';
    }
    visitVariable(e) {
        return e.value;
    }
    visitImport(e) {
        const ext = Path.extname(e.path);
        let base = Path.basename(e.path, ext);
        const dir = Path.dirname(e.path);
        let imp = Path.join(dir, base);
        if (dir == '.')
            imp = "./" + base;
        base = camelcase_1.default(base);
        e.ns = base;
        return `import * as ${base} from '${imp}${ext ? ext : ''}';`;
    }
}
exports.TypescriptVisitor = TypescriptVisitor;
